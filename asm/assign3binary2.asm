main:
lea    ecx,[esp+0x4]                    ;
and    esp,0xfffffff0                   ;
push   DWORD PTR [ecx-0x4]              ;
push   ebp                              ;
mov    ebp,esp                          ;
push   ecx                              ;
; end of prologue
sub    esp,0x24                         ;local stack space
mov    DWORD PTR [ebp-0xc],0x0          ;
push   0x14                             ;0x14 on stack (called function will access as ebp+0xc)
lea    eax,[ebp-0x20]                   ;0xffffcff8 in eax
push   eax                              ;0xffffcff8 on stack (called function will access as ebp+0x8)
call   0x5856513d <populateArray>       ;
;populateArray(void *arrayAddress, int iterationCount)
;populateArray(0xffffcff8,0x14) hex 14 = 20 dec
;============================================================populateArray()
populateArray:
push   ebp                              ;(ebp+4)
mov    ebp,esp                          ;(ebp=esp)
;end of prologue
sub    esp,0x10                         ;
mov    DWORD PTR [ebp-0x4],0x0;var1 = 0  ;ebp-4 = 0;;duplicate line
mov    BYTE PTR [ebp-0x5],0x61;var2=5217 ;BYTE ebp-5= 5217 decimal
mov    DWORD PTR [ebp-0x4],0x0;var1 = 0  ;ebp-4 = 0;;duplicate line
jmp    0x58565177 <populateArray+58>    ;
;
;this whole chunk of code is a loop
;
;
;jump to _handle1
;_handle2:
mov    edx,DWORD PTR [ebp-0x4];edx = var1 (0/1/2...)
mov    eax,DWORD PTR [ebp+0x8];eax = arg1; 0xffffcff8 first arg is a DWORD PTR
add    edx,eax                ;(0xffffcff8/0x...f9/0x...fa)
movzx  eax,BYTE PTR [ebp-0x5] ;eax = var2 (5217/52180/5220...) (byte, 0 extended)
mov    BYTE PTR [edx],al      ;*edx= var2 (0/1/2...)(5217/5218/5220...)
mov    eax,DWORD PTR [ebp-0x4];eax = var1 (0/1/2...)
mov    edx,eax                ;edx = eax  (0/1/2...)
movzx  eax,BYTE PTR [ebp-0x5] ;eax = var2   (5217/5218/5220...)
add    eax,edx                ;(5217/5218/5220...)
mov    BYTE PTR [ebp-0x5],al  ;var2 = eax (5217/5218/5220...)         ;
add    DWORD PTR [ebp-0x4],0x1;var1 = (0/1/2...)
; _handle1:
mov    eax,DWORD PTR [ebp-0x4];eax = var1 (0/1/2...)
cmp    eax,DWORD PTR [ebp+0xc];compare: is eax(var1)(0/1/2...) less than arg2  / 0x14
jl     0x58565157 <populateArray+26>    ;if so loop back
;jump to handle2: if
mov    eax,0x0                          ;
leave                                   ;
ret                                     ;
;=================================================== back to main
add    esp,0x8                          ;
mov    DWORD PTR [ebp-0xc],eax          ;
cmp    DWORD PTR [ebp-0xc],0x0          ;
jne    0x585651c7 <main+65>             ;
;if returned pointer==0{
sub    esp,0xc                          ;
push   0x58565270                       ;
call   0xf7e47360 <puts>                ;
add    esp,0x10                         ;
jmp    0x585651d7 <main+81>             ;
;}
;else{
sub    esp,0xc                          ;
push   0x58565278                       ;
call   0xf7e47360 <puts>                ;
add    esp,0x10                         ;
;}
mov    eax,0x0                          ;
mov    ecx,DWORD PTR [ebp-0x4]          ;
leave                                   ;
lea    esp,[ecx-0x4]                    ;
ret                                     ;
