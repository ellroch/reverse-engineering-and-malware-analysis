
main:
;main prologue
0x595651a5 <+0>:  	lea    ecx,[esp+0x4]
0x595651a9 <+4>:  	and    esp,0xfffffff0
0x595651ac <+7>:  	push   DWORD PTR [ecx-0x4]
0x595651af <+10>: 	push   ebp
0x595651b0 <+11>: 	mov    ebp,esp
0x595651b2 <+13>: 	push   ecx
0x595651b3 <+14>: 	sub    esp,0x24;main esp=ebp-0x24
;main prologue end

;calling __vdso_time
0x595651b6 <+17>: 	mov    DWORD PTR [ebp-0xc],0x0
0x595651bd <+24>: 	sub    esp,0xc;main esp=ebp-30
0x595651c0 <+27>: 	push   0x0
0x595651c2 <+29>: 	call   0xf7fd5a20 <__vdso_time>
0x595651c7 <+34>: 	add    esp,0x10
;end __vdso_time

;calling srandom()
0x595651ca <+37>: 	sub    esp,0xc
0x595651cd <+40>: 	push   eax
0x595651ce <+41>: 	call   0xf7e10980 <srandom>
0x595651d3 <+46>: 	add    esp,0x10
;end srandom()

;calling populateArray()
0x595651d6 <+49>: 	sub    esp,0x8
0x595651d9 <+52>: 	push   0x14;main esp+0x4 / pupulateArray() ebp+0xc : 0x14
0x595651db <+54>: 	lea    eax,[ebp-0x21]
0x595651de <+57>: 	push   eax;main esp / populateArray() ebp+0x8 : 0xffffcff7 --> 0xffd0cc59
0x595651df <+58>: 	call   0x5956513d <populateArray>
;================================================
;function call populateArray(void *arrayAddress, int iterationCount)
populateArray:
push   ebp                              ;(ebp+4)
mov    ebp,esp                          ;(ebp=esp)
;end of prologue
sub    esp,0x10                         ;
mov    DWORD PTR [ebp-0x4],0x0;var1 = 0  ;ebp-4 = 0;;duplicate line
mov    BYTE PTR [ebp-0x5],0x61;var2=5217 ;BYTE ebp-5= 5217 decimal
mov    DWORD PTR [ebp-0x4],0x0;var1 = 0  ;ebp-4 = 0;;duplicate line
jmp    0x58565177 <populateArray+58>    ;
;
;this whole chunk of code is a loop
;
;
;jump to _handle1
;_handle2:
mov    edx,DWORD PTR [ebp-0x4];edx = var1 (0/1/2...)
mov    eax,DWORD PTR [ebp+0x8];eax = arg1; 0xffffcff7 first arg is a DWORD PTR
add    edx,eax                ;(0xffffcff7/0x...f8/0x...f9)
movzx  eax,BYTE PTR [ebp-0x5] ;eax = var2 (5217/5218/5220...) (byte, 0 extended)
mov    BYTE PTR [edx],al      ;*edx= var2 (0/1/2...)(5217/5218/5220...)
mov    eax,DWORD PTR [ebp-0x4];eax = var1 (0/1/2...)
mov    edx,eax                ;edx = eax  (0/1/2...)
movzx  eax,BYTE PTR [ebp-0x5] ;eax = var2   (5217/5218/5220...)
add    eax,edx                ;(5217/5218/5220...)
mov    BYTE PTR [ebp-0x5],al  ;var2 = eax (5217/5218/5220...)         ;
add    DWORD PTR [ebp-0x4],0x1;var1 = (0/1/2...)
; _handle1:
mov    eax,DWORD PTR [ebp-0x4];eax = var1 (0/1/2...)
cmp    eax,DWORD PTR [ebp+0xc];compare: is eax(var1)(0/1/2...) less than arg2  / 0x14
jl     0x58565157 <populateArray+26>    ;if so loop back
;jump to handle2: if
mov    eax,0x0                          ;
leave                                   ;
ret                                     ;
;================================================
0x595651e4 <+63>: 	add    esp,0x10
;end populateArray()

;Control Flow Structure (if/else)
0x595651e7 <+66>: 	mov    DWORD PTR [ebp-0xc],eax
0x595651ea <+69>: 	cmp    DWORD PTR [ebp-0xc],0x0
0x595651ee <+73>: 	jne    0x59565206 <main+97>
;if([ebp-0xc]== 0x0){
0x595651f0 <+75>: 	sub    esp,0x8
0x595651f3 <+78>: 	push   0x14;main esp+0x4 / function ebp+0xc : 0x14
0x595651f5 <+80>: 	lea    eax,[ebp-0x21]
0x595651f8 <+83>: 	push   eax;main esp / function ebp+0x8 : 0xffffcff7 ("aabdgkpv}\205\216\230\243\257\274\312\331\351\372\f\377") - I'm guessing
0x595651f9 <+84>: 	call   0x59565186 <getRandomLetter>
;================================================
;getRandomLetter(char* string, int stringLen)
0x59565186 <+0>:	push   ebp
0x59565187 <+1>:	mov    ebp,esp
0x59565189 <+3>:	sub    esp,0x18
0x5956518c <+6>:	call   0xf7e10f80 <rand>;generate random number, return to: eax (and edx?, else why the cdq operation)
0x59565191 <+11>:	cdq    ;convert double word to quad word
0x59565192 <+12>:	idiv   DWORD PTR [ebp+0xc] ; divide qword edx:eax by 0x14 or 20 decimal, store division in eax, remainder in edx (aldeid source)
0x59565195 <+15>:	mov    DWORD PTR [ebp-0xc],edx ; this is a modulo operation, saving the remainder to local stack space
0x59565198 <+18>:	mov    edx,DWORD PTR [ebp-0xc]
0x5956519b <+21>:	mov    eax,DWORD PTR [ebp+0x8]
0x5956519e <+24>:	add    eax,edx
0x595651a0 <+26>:	movzx  eax,BYTE PTR [eax]
0x595651a3 <+29>:	leave
0x595651a4 <+30>:	ret
;================================================
0x595651fe <+89>: 	add    esp,0x10
0x59565201 <+92>: 	mov    BYTE PTR [ebp-0xd],al
0x59565204 <+95>: 	jmp    0x59565216 <main+113>
;}
;else{
  ;calling puts()
0x59565206 <+97>: 	sub    esp,0xc
0x59565209 <+100>:	push   0x595652b0;string *ptr to "FAILURE"
0x5956520e <+105>:	call   0xf7e47360 <puts>;prints "FAILURE"
0x59565213 <+110>:	add    esp,0x10
  ;end puts()
;}
0x59565216 <+113>:	mov    eax,0x0
0x5956521b <+118>:	mov    ecx,DWORD PTR [ebp-0x4]
0x5956521e <+121>:	leave
0x5956521f <+122>:	lea    esp,[ecx-0x4]
0x59565222 <+125>:	ret
